

## 1.领域驱动概述

微服务系统的设计自然离不开DDD（Domain-Driven Design），它由Eric Evans提出，是一种全新的系统设计和建模方法。领域驱动设计事实上是针对面向对象的分析和设计的一个扩展和延伸，对技术架构进行了分层规划，同时对每个类进行了策略和类型的划分。领域模型是领域驱动的核心。领域模型通过聚合（Aggregate）组织在一起，聚合间有明显的业务边界，这些边界将领域划分为一个个限界上下文（Bounded Context）。采用DDD的设计思想，业务逻辑不再集中在几个大型的类上，而是由大量相对小的领域对象(类)组成，这些类具备自己的状态和行为，每个类是相对完整的独立体，并与现实领域的业务对象映射。领域模型就是由这样许多的细粒度的类组成。基于领域驱动的设计，保证了系统的可维护 性、扩展性和复用性，在处理复杂业务逻辑方面有着先天的优势。

### 1.1 实体（Entity）概述

实体（Entity）：实体就是领域中需要唯一标识的领域概念。因为我们有时需要区分是哪个实体。有两个实体，如果唯一标识不一样，那么即便实体的其他所有属性都一样，我们也认为它们两个是不同的实体；因为实体有生命周期，实体从被创建后可能会被持久化到数据库，然后某个时候又会被取出来。所以，如果我们不为实体定义一种可以唯一区分的标识，那我们就无法区分到底是这个实体还是那个实体。
另外，不应该给实体定义太多的属性或行为，而应该寻找关联，发现其他一些实体或值对象，将属性或行为转移到其他关联的实体或值对象上。比如Customer实体，他有一些地址信息，由于地址信息是一个完整的有业务含义的概念，所以，我们可以定义一个Address对象，然后把Customer的地址相关的信息转移到Address对象上。如果没有Address对象，而把这些地址信息直接放在Customer对象上，并且如果对于一些其他的类似Address的信息也都直接放在Customer上，会导致Customer对象很混乱，结构不清晰，最终导致它难以维护和理解。

### 1.2 值对象（Value Object）概述

在领域中，并不是每一个事物都必须有一个唯一标识，也就是说我们不关心对象是哪个，而只关心对象是什么。就以上面的地址对象Address为例，如果有两个Customer的地址信息是一样的，我们就会认为这两个Customer的地址是同一个。也就是说只要地址信息一样，我们就认为是同一个地址。
用程序的方式来表达就是，如果两个对象的所有的属性的值都相同，我们会认为它们是同一个对象的话，那么我们就可以把这种对象设计为值对象。因此，值对象没有唯一标识，这是它和实体的最大不同。另外值对象在判断是否是同一个对象时是通过它们的所有属性是否相同，如果相同则认为是同一个值对象；而我们在区分是否是同一个实体时，只看实体的唯一标识是否相同，而不管实体的属性是否相同；值对象另外一个明显的特征是不可变，即所有属性都是只读的。因为属性是只读的，所以可以被安全的共享；当共享值对象时，一般有复制和共享两种做法，具体采用哪种做法还要根据实际情况而定；另外，我们应该给值对象设计的尽量简单，不要让它引用很多其它的对象，因为它只是一个值。实体和值对象的对比，如下表所示:

|  | 概念 | 区别 | 举例说明 |
| --- | --- | --- | --- |
| 实体 | 实体表示那些具有生命周期并且会在其生命周期中发生改变的东西 | 实体是有唯一标识的，只要唯一标识不同就是两个不同的实体   | 比如:央行发行了一些100元的钞票，每个钞票都有唯一识别的标识，此时两张100元的钞票就是不同的实体。|
| 值对象 | 值对象则表示起描述性作用的并且可以相互替换的概念 | 值对象是没有唯一标识的，只是数据传输的载体。描述性属性字段来实现  | 比如：我们花了100元买了一本书，我们只是关心货币的数量而已，而不是关心具体使用了哪一张100元的钞票，即两张100元的钞票是可以互换的，此时的钞票就是值对象 | 2-3 |

### 1.3  领域服务（Domain Service）

   领域中的一些概念不太适合建模为对象，即归类到实体对象或值对象，因为它们本质上就是一些操作，一些动作，而不是事物。这些操作或动作往往会涉及到多个领域对象，并且需要协调这些领域对象共同完成这个操作或动作。如果强行将这些操作职责分配给任何一个对象，则被分配的对象就是承担一些不该承担的职责，从而会导致对象的职责不明确很混乱。但是基于类的面向对象语言规定任何属性或行为都必须放在对象里面。所以我们需要寻找一种新的模式来表示这种跨多个对象的操作，DDD认为服务是一个很自然的范式用来对应这种跨多个对象的操作，所以就有了领域服务这个模式。领域服务本来就是来处理这种场景的。比如要对密码进行解密，可以创建一个PasswordService来专门处理加解密的问题。
    领域服务还有一个很重要的功能就是可以避免领域逻辑泄露到应用层。因为如果没有领域服务，那么应用层会直接调用领域对象完成本该属于领域服务该做的操作，这样一来，领域层可能会把一部分领域泄露到应用层。因此，引入领域服务可以有效的防止领域层的逻辑泄露到应用层。对于应用层来说，从可理解的角度来讲，通过调用领域服务提供的简单，易懂，明确的接口肯定也要比直接操纵领域对象容易的多。
    那如何去识别领域服务呢？主要看它是否满足以下三个特征： 
* 服务执行的操作代表了一个领域概念，这个领域概念无法自然地隶属于一个实体或者值对象。 
* 被执行的操作涉及到领域中的其他的对象。 
* 操作是无状态的。


### 1.3 聚合及聚合根
聚合，它通过定义对象之间清晰的所属关系和边界来实现领域模型的内聚，并避免了错综复杂的难以维护的对象关系网的形成。聚合定义了一组具有内聚关系的相关对象的集合，我们把聚合看作是一个修改数据的单元。聚合中所包含的对象之间具有密不可分的联系，他们是内聚在一起的。比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。一个聚合中可以包含多个实体和值对象，因此聚合也被称为根实体。如图25-1所示,就是一个聚合，Customer是聚合根也是实体，address是值对象，ContactInfo也是值对象。




